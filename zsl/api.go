package zsl

import (
	"crypto/rand"
	"encoding/binary"
	"encoding/hex"
	"errors"
	"fmt"
	"github.com/FiloSottile/zcash-mini/sha256"
	"github.com/glyff/glyff-node/common"
	"github.com/jpmorganchase/zsl-q/zsl-golang/zsl/snark"
	"github.com/minio/blake2b-simd"
	"golang.org/x/crypto/chacha20poly1305"
	"golang.org/x/crypto/curve25519"
	"io/ioutil"
	"math"
	"strconv"
	"strings"
)

const (
	ZSL_PROOF_SIZE                                   int = 584
	ZSL_TREE_DEPTH                                       = 29
	ZSL_V_SIZE                                           = 16
	ZSL_RHO_SIZE                                         = 32
	ZSL_NOTEPLAINTEXT_SIZE                               = ZSL_V_SIZE + ZSL_RHO_SIZE
	ZSL_NOTEENCRYPTION_AUTH_BYTES                        = 16
	ZSL_NOTEENCRYPTION_CIPHER_KEYSIZE                    = 32
	ZSL_crypto_aead_chacha20poly1305__IETF_NPUBBYTES     = 12
	ZSL_crypto_generichash_blake2b_PERSONALBYTES         = 16
)

type PublicZSLAPI struct {
}

func NewPublicZSLAPI() *PublicZSLAPI {
	return &PublicZSLAPI{}
}

func CreateParamsShielding() {
	snark.CreateParamsShielding()
}

func CreateParamsUnshielding() {
	snark.CreateParamsUnshielding()
}

func prfAddr(dst, ask []byte, t byte) {
	if len(dst) < 32 {
		panic("prfAddr called with a too small dst")
	}

	buf := make([]byte, 64)
	copy(buf, ask)

	buf[0] |= 0xc0
	buf[32] = t

	type compressor interface {
		SumNoPadding([]byte) []byte
	}

	d := sha256.New()
	d.Write(buf)
	d.(compressor).SumNoPadding(dst[:0])
}

func random_uint256(s []byte) []byte {
	b := make([]byte, 32)
	if s != nil {
		copy(b, []byte(s))
	} else {
		if _, err := rand.Read(b); err != nil {
			panic(err)
		}
	}
	return b
}

//SK
func random_uint252(s []byte) []byte {
	if s == nil {
		s = random_uint256(nil)
	}
	s[0] &= 0x0f
	return s
}

//PK_ENC
func generate_pubkey(sk_enc []byte) []byte {
	var pk_enc, src [32]byte
	prfAddr(src[:], sk_enc, 1)
	curve25519.ScalarBaseMult(&pk_enc, &src)
	return pk_enc[:]
}

//SK_ENC
func generate_privkey(a_sk []byte) []byte {
	sk_enc := make([]byte, 64)
	prfAddr(sk_enc, a_sk, 0)
	prfAddr(sk_enc[32:], a_sk, 1)
	// Clamp PRF output to a valid Curve25519 secret key.
	sk_enc[32] &= 248
	sk_enc[63] &= 127
	sk_enc[63] |= 64
	return sk_enc
}

//PK_ENC ZCASH
func ZC_generate_pubkey(sk_enc []byte) []byte {
	var pk_enc, _sk_enc [32]byte
	copy(_sk_enc[:], sk_enc)
	curve25519.ScalarBaseMult(&pk_enc, &_sk_enc)
	return pk_enc[:]
}

//SK_ENC ZCASH
func ZC_generate_privkey(a_sk []byte) []byte {
	sk_enc := make([]byte, 32)
	prfAddr(sk_enc[:], a_sk, 1)
	// Clamp PRF output to a valid Curve25519 secret key.
	sk_enc[0] &= 248
	sk_enc[31] &= 127
	sk_enc[31] |= 64
	return sk_enc
}

// See "5.4.4.2 Sprout Key Derivation"
func KDF(dhsecret [32]byte, epk []byte, pk_enc [32]byte, nonce byte) []byte {
	if nonce == 255 {
		panic("no additional nonce space for KDF")
	}

	kdfinput := make([]byte, 128)
	// Sprout calls for the first 32 bytes of `kdfinput` to be `h_sig`. Since we're
	// not working with an `h_sig` here, we set them to 0.
	copy(kdfinput[32:], dhsecret[:])
	copy(kdfinput[64:], epk)
	copy(kdfinput[96:], pk_enc[:])

	kdftag := make([]byte, ZSL_crypto_generichash_blake2b_PERSONALBYTES)
	copy(kdftag, "ZcashKDF")
	kdftag[8] = nonce

	var c = blake2b.Config{ZSL_NOTEENCRYPTION_CIPHER_KEYSIZE,
		nil, //No Key
		nil, //No Salt
		kdftag,
		nil} // No params for tree hashing
	if d, err := blake2b.New(&c); err != nil {
		panic(err)
	} else {
		d.Write(kdfinput)
		var in []byte
		return d.Sum(in)
	}
}

/*b , err := hex.DecodeString(strings.TrimPrefix(pk_enc, "0x"))
if err != nil {
	panic("error decoding pk_enc")
}*/

func encryptor(pk_enc []byte, message []byte) ([]byte, []byte, error) {

	var _pk_enc [32]byte
	copy(_pk_enc[:], pk_enc)

	// Create the ephemeral keypair
	esk := random_uint256(nil)
	epk := ZC_generate_pubkey(esk)

	var _esk [32]byte
	copy(_esk[:], esk)

	//generate shared secret
	var dhsecret [32]byte
	curve25519.ScalarMult(&dhsecret, &_esk, &_pk_enc)

	//construct the simmetric key
	var nonce byte
	K := KDF(dhsecret, epk, _pk_enc, nonce)

	//increment the number of encryptions we have performed
	nonce++

	//the nonce is zero because we never reuse keys
	var cipher_nonce uint16 = 0
	cn := make([]byte, ZSL_crypto_aead_chacha20poly1305__IETF_NPUBBYTES)
	binary.LittleEndian.PutUint16(cn, cipher_nonce)

	var cp []byte

	//Fill with Key
	o, err := chacha20poly1305.New(K)

	//Encrypt data
	ciphertext := o.Seal(cp,
		cn,
		message,
		nil) //No additional data

	return ciphertext, epk, err
}

func decryptor(ciphertext []byte, sk_enc []byte, epk []byte, cipher_nonce uint16) ([]byte, error) {

	pk_enc := ZC_generate_pubkey(sk_enc)
	var _pk_enc [32]byte
	copy(_pk_enc[:], pk_enc)

	var _epk [32]byte
	copy(_epk[:], epk)

	var _sk_enc [32]byte
	copy(_sk_enc[:], sk_enc)

	//generate shared secret
	var dhsecret [32]byte
	curve25519.ScalarMult(&dhsecret, &_sk_enc, &_epk)

	//construct the simmetric key
	var nonce byte
	K := KDF(dhsecret, epk, _pk_enc, nonce)

	cn := make([]byte, ZSL_crypto_aead_chacha20poly1305__IETF_NPUBBYTES)
	binary.LittleEndian.PutUint16(cn, cipher_nonce)

	var cp []byte

	//Fill with Key
	o, err := chacha20poly1305.New(K)

	//Decrypt data
	cleartext, err := o.Open(cp,
		cn,
		ciphertext,
		nil) //No additional data

	return cleartext, err
}

func (api *PublicZSLAPI) GenerateZKeypair() (map[string]interface{}, error) {
	result := make(map[string]interface{})

	buf := random_uint252(nil)
	apk := sha256.Sum256(buf)
	sk_enc := ZC_generate_privkey(buf)
	pk_enc := ZC_generate_pubkey(sk_enc)

	addr := make([]byte, 64)

	copy(addr[0:32], apk[:])
	copy(addr[32:64], pk_enc[:])

	prefix := string("0x")
	zaddr_1 := prefix + hex.EncodeToString(addr)

	result["a_sk"] = common.BytesToHash(buf)
	result["a_pk"] = common.BytesToHash(apk[:])
	result["viewingKey_skenc"] = common.BytesToHash(sk_enc) //Base58Encode(sk_enc, ProdViewingKey)
	result["publicKey_pkenc"] = common.BytesToHash(pk_enc)
	result["shieldedAddress"] = zaddr_1 //zaddr_1 //Base58Encode(addr, ProdAddress)

	return result, nil

}
func (api *PublicZSLAPI) TestZaddr(shieldedAddress string) (map[string]interface{}, error) {
	result := make(map[string]interface{})

	b, _ := hex.DecodeString(strings.TrimPrefix(shieldedAddress, "0x"))
	out_pk_1 := common.BytesToHash(b[0:32])
	out_pkenc_1 := common.BytesToHash(b[32:64])

	result["out_pk_1"] = out_pk_1
	result["out_pkenc_1"] = out_pkenc_1
	result["shieldedAddress"] = shieldedAddress

	return result, nil

}

func (api *PublicZSLAPI) Test() (map[string]interface{}, error) {
	result := make(map[string]interface{})

	a_sk := random_uint252(random_uint256([]byte("21035d60bc1983e37950ce4803418a8fb33ea68d5b937ca382ecbae7564d6a07")))
	apk := sha256.Sum256(a_sk)
	sk_enc := ZC_generate_privkey(a_sk)
	pk_enc := ZC_generate_pubkey(sk_enc)

	var value float64
	value = 561.2863

	o, _ := hex.DecodeString("23dd2d922c096689654efc3d5913e2f804b3cccd6b583d780582991048a23db7")
	m := make([]byte, 48)
	r := fmt.Sprintf("%x\n", math.Float64bits(value))

	copy(m[:], o[:])
	copy(m[32:48], r)

	ciphertext, epk, err_e := encryptor(pk_enc, m)

	var cleartext []byte
	var err, err_d error
	var n2 uint64
	var s string
	var bs []byte

	if err_e == nil {
		cleartext, err_d = decryptor(ciphertext, sk_enc, epk, 0)
		if err_d != nil {
			err = errors.New("error decrypting message")
		}
		s = hex.EncodeToString(cleartext)[64:]
		bs, _ = hex.DecodeString(s)

		n, err := strconv.ParseUint(string(bs), 16, 64)
		if err != nil {
			panic(err)
		}
		n2 = uint64(n)

	} else {
		err = errors.New("error encrypting message")
	}

	result["sk_enc"] = common.BytesToHash(sk_enc)
	result["pk_enc"] = common.BytesToHash(pk_enc)
	result["epk"] = common.BytesToHash(epk)
	result["apk"] = common.BytesToHash(apk[:])
	result["ciphertext_hash"] = common.BytesToHash(ciphertext)
	result["cp_len"] = len(ciphertext)
	result["epk_len"] = len(epk)
	result["cleartext"] = hex.EncodeToString(cleartext)
	result["ciphertext"] = hex.EncodeToString(ciphertext)
	result["err_e"] = err_e
	result["err_d"] = err_d
	result["value"] = math.Float64frombits(n2)
	return result, err
}

func (api *PublicZSLAPI) NoteDecrypt(a_sk string, blob string) (map[string]interface{}, error) {
	result := make(map[string]interface{})

	a, err := hex.DecodeString(strings.TrimPrefix(a_sk, "0x"))
	if err != nil {
		err = errors.New("error decoding a_sk")
	}

	b, err := hex.DecodeString(strings.TrimPrefix(blob, "0x"))
	if err != nil {
		err = errors.New("error decoding blob")
	}

	ciphertext := b[0:64]
	epk := b[64:96]
	sk_enc := ZC_generate_privkey(a)

	var cleartext []byte
	var n2 uint64
	var s string
	var bs []byte
	cleartext, err = decryptor(ciphertext, sk_enc, epk, 0)
	if err != nil {
		//panic(err)
		err = errors.New("error decrypting message")
	} else {
		s = hex.EncodeToString(cleartext)[64:]
		bs, _ = hex.DecodeString(s)

		n, err := strconv.ParseUint(string(bs), 16, 64)
		if err != nil {
			err = errors.New("error converting cleartext")
		}
		n2 = uint64(n)

		result["cleartext"] = hex.EncodeToString(cleartext)
		result["out_rho_1"] = hex.EncodeToString(cleartext)[:64]
		result["value"] = math.Float64frombits(n2)
	}

	return result, err
}

// Note: API function names should match those defined in web3ext.go, first character upper case as external function.
func (api *PublicZSLAPI) LoadTracker(filename string) (string, error) {
	data, err := ioutil.ReadFile(filename)
	return string(data[:]), err
}

// TODO: Post-demo, sanitize filenames and check exiting files before over-writing.
func (api *PublicZSLAPI) SaveTracker(filename string, data string) bool {
	b := []byte(data)
	err := ioutil.WriteFile(filename, b, 0644)
	return err == nil
}

// Convert proof hex string from javascript to correct format.  Trims leading 0x if present.
func getProofFromHex(s string) ([ZSL_PROOF_SIZE]byte, error) {
	var proof [ZSL_PROOF_SIZE]byte

	buf, err := hex.DecodeString(strings.TrimPrefix(s, "0x"))
	if err != nil {
		return proof, err
	}

	proofSize := len(buf)
	if proofSize != ZSL_PROOF_SIZE {
		return proof, errors.New(fmt.Sprintf("ZSL error, proof must have size of %d bytes but got %d.\n", ZSL_PROOF_SIZE, proofSize))
	}

	copy(proof[:], buf[:ZSL_PROOF_SIZE])
	return proof, nil
}

// send nullifier, SHA256(0x00 || rho)
func computeSendNullifier(rho []byte) []byte {
	h := sha256.New()
	h.Write([]byte{0x00})
	h.Write(rho)
	return h.Sum(nil)
}

// spend nullifier SHA256(0x01 || rho || sk)
func computeSpendNullifier(rho []byte, sk [32]byte) []byte {
	h := sha256.New()
	h.Write([]byte{0x01})
	h.Write(rho)
	h.Write(sk[:])
	return h.Sum(nil)
}

// spend nullifier SHA256(0x01 || rho || sk || addr)
func computeSpendNullifierAuthenticated(rho []byte, sk [32]byte, addr [20]byte) []byte {
	h := sha256.New()
	h.Write([]byte{0x01})
	h.Write(rho)
	h.Write(sk[:])
	h.Write(addr[:])
	return h.Sum(nil)
}

// cm = SHA256(rho || pk || v) where v is in little endian byte order
func computeCommitment(rho [32]byte, pk [32]byte, v uint64) []byte {
	vbuf := make([]byte, 8)
	binary.LittleEndian.PutUint64(vbuf, v)

	h := sha256.New()
	h.Write(rho[:])
	h.Write(pk[:])
	h.Write(vbuf)
	return h.Sum(nil)
}

func (api *PublicZSLAPI) GetCommitment(rho common.Hash, pk common.Hash, value float64) common.Hash {
	return common.BytesToHash(computeCommitment(rho, pk, uint64(value)))
}

func (api *PublicZSLAPI) GetSendNullifier(rho common.Hash) common.Hash {
	return common.BytesToHash(computeSendNullifier(rho[:]))
}

func (api *PublicZSLAPI) GetSpendNullifier(rho common.Hash, sk common.Hash) common.Hash {
	return common.BytesToHash(computeSpendNullifier(rho[:], sk))
}

func (api *PublicZSLAPI) CreateShielding(rho common.Hash, pk common.Hash, value float64) (map[string]interface{}, error) {
	result := make(map[string]interface{})

	snark.Init()
	proof := snark.ProveShielding(rho, pk, uint64(value))
	send_nf := computeSendNullifier(rho[:])
	cm := computeCommitment(rho, pk, uint64(value))
	result["proof"] = "0x" + hex.EncodeToString(proof[:])
	result["cm"] = common.BytesToHash(cm)
	result["send_nf"] = common.BytesToHash(send_nf)
	return result, nil
}

func (api *PublicZSLAPI) CreateUnshielding(rho common.Hash, sk common.Hash, addr common.Address, value float64, treeIndex float64, authPath []string) (map[string]interface{}, error) {
	result := make(map[string]interface{})

	// copy authentication path array into two dimensional array (as required by snark.ProveUnshielding())
	if len(authPath) != ZSL_TREE_DEPTH {
		return result, errors.New(fmt.Sprintf("Authentication path must be %d in length", ZSL_TREE_DEPTH))
	}
	var authenticationPath [ZSL_TREE_DEPTH][32]byte
	for i := 0; i < ZSL_TREE_DEPTH; i++ {
		b, err := hex.DecodeString(strings.TrimPrefix(authPath[i], "0x"))
		if err != nil {
			return result, err
		}
		var uncle [32]byte
		copy(uncle[:], b[:32])
		authenticationPath[i] = uncle
	}

	snark.Init()
	proof := snark.ProveUnshielding(rho, sk, addr, uint64(value), uint64(treeIndex), authenticationPath)
	send_nf := computeSendNullifier(rho[:])
	spend_nf := computeSpendNullifierAuthenticated(rho[:], sk, addr)
	result["proof"] = "0x" + hex.EncodeToString(proof[:])
	result["send_nf"] = common.BytesToHash(send_nf)
	result["spend_nf"] = common.BytesToHash(spend_nf)
	return result, nil
}

func (api *PublicZSLAPI) CreateShieldedTransfer(
	rho_1 common.Hash, sk_1 common.Hash, value_1 float64, treeIndex_1 float64, authPath_1 []string,
	rho_2 common.Hash, sk_2 common.Hash, value_2 float64, treeIndex_2 float64, authPath_2 []string,
	out_rho_1 common.Hash, shieldedAddress string, out_value_1 float64,
	out_rho_2 common.Hash, out_pk_2 common.Hash, out_value_2 float64,
) (map[string]interface{}, error) {
	result := make(map[string]interface{})

	b, _ := hex.DecodeString(strings.TrimPrefix(shieldedAddress, "0x"))
	out_pk_1 := common.BytesToHash(b[0:32])
	out_pkenc_1 := common.BytesToHash(b[32:64])

	// copy authentication path array into two dimensional array (as required by snark.ProveUnshielding())
	if len(authPath_1) != ZSL_TREE_DEPTH {
		return result, errors.New(fmt.Sprintf("Authentication path 1 must be %d in length", ZSL_TREE_DEPTH))
	}
	var authenticationPath_1 [ZSL_TREE_DEPTH][32]byte
	for i := 0; i < ZSL_TREE_DEPTH; i++ {
		b, err := hex.DecodeString(strings.TrimPrefix(authPath_1[i], "0x"))
		if err != nil {
			return result, err
		}
		var uncle [32]byte
		copy(uncle[:], b[:32])
		authenticationPath_1[i] = uncle
	}

	if len(authPath_2) != ZSL_TREE_DEPTH {
		return result, errors.New(fmt.Sprintf("Authentication path 2 must be %d in length", ZSL_TREE_DEPTH))
	}
	var authenticationPath_2 [ZSL_TREE_DEPTH][32]byte
	for i := 0; i < ZSL_TREE_DEPTH; i++ {
		b, err := hex.DecodeString(strings.TrimPrefix(authPath_2[i], "0x"))
		if err != nil {
			return result, err
		}
		var uncle [32]byte
		copy(uncle[:], b[:32])
		authenticationPath_2[i] = uncle
	}

	snark.Init()
	proof := snark.ProveTransfer(
		rho_1, sk_1, uint64(value_1), uint64(treeIndex_1), authenticationPath_1,
		rho_2, sk_2, uint64(value_2), uint64(treeIndex_2), authenticationPath_2,
		out_rho_1, out_pk_1, uint64(out_value_1),
		out_rho_2, out_pk_2, uint64(out_value_2),
	)

	send_nf_1 := computeSendNullifier(out_rho_1[:])
	send_nf_2 := computeSendNullifier(out_rho_2[:])
	spend_nf_1 := computeSpendNullifier(rho_1[:], sk_1)
	spend_nf_2 := computeSpendNullifier(rho_2[:], sk_2)
	cm_1 := computeCommitment(out_rho_1, out_pk_1, uint64(out_value_1))
	cm_2 := computeCommitment(out_rho_2, out_pk_2, uint64(out_value_2))

	o := out_rho_1.Bytes()
	r := fmt.Sprintf("%x\n", math.Float64bits(out_value_1))

	m := make([]byte, ZSL_NOTEPLAINTEXT_SIZE)
	copy(m[:], o)
	copy(m[32:48], r)

	ciphertext, epk, err := encryptor(out_pkenc_1.Bytes(), m)
	if err != nil {
		panic("could not encrypt note")
	}

	blob := make([]byte, (len(ciphertext) + len(epk)))
	copy(blob, ciphertext[:])
	copy(blob[len(ciphertext):], epk[:])

	result["proof"] = "0x" + hex.EncodeToString(proof[:])
	result["out_send_nf_1"] = common.BytesToHash(send_nf_1)
	result["out_send_nf_2"] = common.BytesToHash(send_nf_2)
	result["in_spend_nf_1"] = common.BytesToHash(spend_nf_1)
	result["in_spend_nf_2"] = common.BytesToHash(spend_nf_2)
	result["out_cm_1"] = common.BytesToHash(cm_1)
	result["out_cm_2"] = common.BytesToHash(cm_2)
	result["out_pk_1"] = out_pk_1
	result["out_pkenc_1"] = out_pkenc_1
	result["message"] = hex.EncodeToString(m)
	result["ciphertext"] = hex.EncodeToString(ciphertext)
	result["epk"] = hex.EncodeToString(epk)
	result["blob"] = hex.EncodeToString(blob)
	return result, nil
}

// glyff: zsl.verifyShielding(proof, send_nf, cm, value);
// Javascript numbers are floats, there is no support for 64-bit integers.
func (api *PublicZSLAPI) VerifyShielding(proofHex string, send_nf common.Hash, cm common.Hash, value float64) (bool, error) {

	proof, err := getProofFromHex(proofHex)
	if err != nil {
		return false, err
	}

	snark.Init()
	result := snark.VerifyShielding(proof, send_nf, cm, uint64(value))
	return result, nil
}

// glyff: zsl.verifyUnshielding(proof, spend_nf, rt, addr, value);
// Javascript numbers are floats, there is no support for 64-bit integers.
func (api *PublicZSLAPI) VerifyUnshielding(proofHex string, spend_nf common.Hash, rt common.Hash, addr common.Address, value float64) (bool, error) {

	proof, err := getProofFromHex(proofHex)
	if err != nil {
		return false, err
	}

	snark.Init()
	result := snark.VerifyUnshielding(proof, spend_nf, rt, addr, uint64(value))
	return result, nil
}

func (api *PublicZSLAPI) VerifyShieldedTransfer(
	proofHex string,
	anchor common.Hash,
	spend_nf_1 common.Hash,
	spend_nf_2 common.Hash,
	send_nf_1 common.Hash,
	send_nf_2 common.Hash,
	cm_1 common.Hash,
	cm_2 common.Hash) (bool, error) {

	proof, err := getProofFromHex(proofHex)
	if err != nil {
		return false, err
	}

	snark.Init()
	result := snark.VerifyTransfer(proof, anchor, spend_nf_1, spend_nf_2, send_nf_1, send_nf_2, cm_1, cm_2)
	return result, nil
}

// Generate 32 bytes of randomness
func (api *PublicZSLAPI) GetRandomness() (common.Hash, error) {
	buf := make([]byte, 32)
	_, err := rand.Read(buf)
	if err != nil {
		return common.BytesToHash(buf), err
	}
	return common.BytesToHash(buf), nil
}

// Create a shielded address and return all components: a_sk, a_pk
func (api *PublicZSLAPI) GetNewAddress() (map[string]interface{}, error) {
	result := make(map[string]interface{})
	buf := make([]byte, 32)
	_, err := rand.Read(buf)
	if err != nil {
		return result, err
	}
	buf[0] &= 0x0f
	result["a_sk"] = common.BytesToHash(buf)
	apk := sha256.Sum256(buf)
	result["a_pk"] = common.BytesToHash(apk[:])
	return result, nil
}

// Test copied from from snark_test.go
func (api *PublicZSLAPI) DebugShielding() (bool, error) {

	snark.Init()

	proof := snark.ProveShielding(
		[32]byte{0xfb, 0xac, 0xfb, 0xac, 0xfb, 0xac, 0xfb, 0xac, 0xfb, 0xac, 0xfb, 0xac, 0xfb, 0xac, 0xfb, 0xac, 0xfb, 0xac, 0xfb, 0xac, 0xfb, 0xac, 0xfb, 0xac, 0xfb, 0xac, 0xfb, 0xac, 0xfb, 0xac, 0xfb, 0xac},
		[32]byte{0xac, 0xfb, 0xac, 0xfb, 0xac, 0xfb, 0xac, 0xfb, 0xac, 0xfb, 0xac, 0xfb, 0xac, 0xfb, 0xac, 0xfb, 0xac, 0xfb, 0xac, 0xfb, 0xac, 0xfb, 0xac, 0xfb, 0xac, 0xfb, 0xac, 0xfb, 0xac, 0xfb, 0xac, 0xfb},
		2378237)

	result := snark.VerifyShielding(proof,
		[32]byte{0x35, 0xf7, 0xff, 0x84, 0x5e, 0x47, 0x86, 0xd6, 0x44, 0xc9, 0xc9, 0x05, 0xfe, 0x68, 0xfd, 0x0f, 0x60, 0x2f, 0xea, 0x0b, 0xeb, 0x2c, 0x34, 0x1b, 0xc5, 0xd2, 0xde, 0xfc, 0x17, 0xc3, 0x2e, 0x86},
		[32]byte{0xd6, 0x21, 0x8a, 0x07, 0x71, 0x4d, 0xd9, 0xfa, 0xc9, 0x2b, 0xde, 0xef, 0xd3, 0xf4, 0xc0, 0xd7, 0x69, 0xf4, 0x0f, 0x4b, 0x04, 0x3a, 0xd7, 0xe6, 0x7e, 0x73, 0x75, 0xed, 0xc4, 0x98, 0xe4, 0x5c},
		2378237)
	if !result {
		return false, errors.New("proof was not invalid as expected")
	}

	result = snark.VerifyShielding(proof,
		[32]byte{0x35, 0xf7, 0xff, 0x84, 0x5e, 0x47, 0x86, 0xd6, 0x44, 0xc9, 0xc9, 0x05, 0xfe, 0x68, 0xfd, 0x0f, 0x60, 0x2f, 0xea, 0x0b, 0xeb, 0x2c, 0x34, 0x1b, 0xc5, 0xd2, 0xde, 0xfc, 0x17, 0xc3, 0x2e, 0x86},
		[32]byte{0xd6, 0x21, 0x8a, 0x07, 0x71, 0x4d, 0xd9, 0xfa, 0xc9, 0x2b, 0xde, 0xef, 0xd3, 0xf4, 0xc0, 0xd7, 0x69, 0xf4, 0x0f, 0x4b, 0x04, 0x3a, 0xd7, 0xe6, 0x7e, 0x73, 0x75, 0xed, 0xc4, 0x98, 0xe4, 0x5c},
		2378236)
	if result {
		return false, errors.New("proof was not invalid as expected")
	}

	result = snark.VerifyShielding(proof,
		[32]byte{0x34, 0xf7, 0xff, 0x84, 0x5e, 0x47, 0x86, 0xd6, 0x44, 0xc9, 0xc9, 0x05, 0xfe, 0x68, 0xfd, 0x0f, 0x60, 0x2f, 0xea, 0x0b, 0xeb, 0x2c, 0x34, 0x1b, 0xc5, 0xd2, 0xde, 0xfc, 0x17, 0xc3, 0x2e, 0x86},
		[32]byte{0xd6, 0x21, 0x8a, 0x07, 0x71, 0x4d, 0xd9, 0xfa, 0xc9, 0x2b, 0xde, 0xef, 0xd3, 0xf4, 0xc0, 0xd7, 0x69, 0xf4, 0x0f, 0x4b, 0x04, 0x3a, 0xd7, 0xe6, 0x7e, 0x73, 0x75, 0xed, 0xc4, 0x98, 0xe4, 0x5c},
		2378237)
	if result {
		return false, errors.New("proof was not invalid as expected")
	}

	return true, nil
}

// Test copied from from snark_test.go
func (api *PublicZSLAPI) DebugUnshielding() (bool, error) {

	snark.Init()

	proof := snark.ProveUnshielding(
		[32]byte{0xde, 0xde, 0xff, 0xdd, 0xde, 0xde, 0xff, 0xdd, 0xde, 0xde, 0xff, 0xdd, 0xde, 0xde, 0xff, 0xdd, 0xde, 0xde, 0xff, 0xdd, 0xde, 0xde, 0xff, 0xdd, 0xde, 0xde, 0xff, 0xdd, 0xde, 0xde, 0xff, 0xdd},
		[32]byte{0xf0, 0xf0, 0xf0, 0xf0, 0x0f, 0x0f, 0x0f, 0xff, 0xff, 0xff, 0xff, 0xf0, 0x00, 0x00, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x00, 0xf0, 0x00, 0x0f, 0x0f, 0x00, 0xf0, 0x0f, 0x0f, 0x0f, 0x0f, 0x00, 0xff},
		[20]byte{0xed, 0x9d, 0x02, 0xe3, 0x82, 0xb3, 0x48, 0x18, 0xe8, 0x8b, 0x88, 0xa3, 0x09, 0xc7, 0xfe, 0x71, 0xe6, 0x5f, 0x41, 0x9d},
		2378237,
		0,
		[29][32]byte{
			{0x80, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x01, 0x00},
			{0x80, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x01, 0x00},
			{0x80, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x01, 0x00},
			{0x80, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x01, 0x00},
			{0x80, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x01, 0x00},
			{0x80, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x01, 0x00},
			{0x80, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x01, 0x00},
			{0x80, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x01, 0x00},
			{0x80, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x01, 0x00},
			{0x80, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x01, 0x00},
			{0x80, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x01, 0x00},
			{0x80, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x01, 0x00},
			{0x80, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x01, 0x00},
			{0x80, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x01, 0x00},
			{0x80, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x01, 0x00},
			{0x80, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x01, 0x00},
			{0x80, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x01, 0x00},
			{0x80, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x01, 0x00},
			{0x80, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x01, 0x00},
			{0x80, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x01, 0x00},
			{0x80, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x01, 0x00},
			{0x80, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x01, 0x00},
			{0x80, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x01, 0x00},
			{0x80, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x01, 0x00},
			{0x80, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x01, 0x00},
			{0x80, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x01, 0x00},
			{0x80, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x01, 0x00},
			{0x80, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x01, 0x00},
			{0x80, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x01, 0x00}})

	result := snark.VerifyUnshielding(proof,
		[32]byte{0x3a, 0x2c, 0xeb, 0xa3, 0x2e, 0xf0, 0x24, 0x56, 0xd5, 0x19, 0xf0, 0x66, 0xe6, 0xb6, 0xf8, 0xa2, 0x72, 0xb6, 0x88, 0x4a, 0xb5, 0x73, 0x61, 0x58, 0xc6, 0x30, 0x8e, 0x04, 0x38, 0x2a, 0x78, 0xaf},
		[32]byte{0x86, 0x10, 0x65, 0x27, 0x39, 0xac, 0x0c, 0x6b, 0xb6, 0xb5, 0x35, 0x36, 0x49, 0xbb, 0x82, 0x2b, 0x26, 0x54, 0x3f, 0x0e, 0xbe, 0x88, 0xf3, 0x2a, 0x48, 0x9a, 0x56, 0x84, 0x3c, 0xd0, 0x4f, 0x03},
		[20]byte{0xed, 0x9d, 0x02, 0xe3, 0x82, 0xb3, 0x48, 0x18, 0xe8, 0x8b, 0x88, 0xa3, 0x09, 0xc7, 0xfe, 0x71, 0xe6, 0x5f, 0x41, 0x9d},
		2378237)
	if !result {
		return false, errors.New("proof was not valid as expected")
	}

	result = snark.VerifyUnshielding(proof,
		[32]byte{0x3a, 0x2c, 0xeb, 0xa3, 0x2e, 0xf0, 0x24, 0x56, 0xd5, 0x19, 0xf0, 0x66, 0xe6, 0xb6, 0xf8, 0xa2, 0x72, 0xb6, 0x88, 0x4a, 0xb5, 0x73, 0x61, 0x58, 0xc6, 0x30, 0x8e, 0x04, 0x38, 0x2a, 0x78, 0xaf},
		[32]byte{0x86, 0x10, 0x65, 0x27, 0x39, 0xac, 0x0c, 0x6b, 0xb6, 0xb5, 0x35, 0x36, 0x49, 0xbb, 0x82, 0x2b, 0x26, 0x54, 0x3f, 0x0e, 0xbe, 0x88, 0xf3, 0x2a, 0x48, 0x9a, 0x56, 0x84, 0x3c, 0xd0, 0x4f, 0x03},
		[20]byte{0xed, 0x9d, 0x02, 0xe3, 0x82, 0xb3, 0x48, 0x18, 0xe8, 0x8b, 0x88, 0xa3, 0x09, 0xc7, 0xfe, 0x71, 0xe6, 0x5f, 0x41, 0x9d},
		2378236)
	if result {
		return false, errors.New("proof was not invalid as expected")
	}

	result = snark.VerifyUnshielding(proof,
		[32]byte{0x39, 0x2c, 0xeb, 0xa3, 0x2e, 0xf0, 0x24, 0x56, 0xd5, 0x19, 0xf0, 0x66, 0xe6, 0xb6, 0xf8, 0xa2, 0x72, 0xb6, 0x88, 0x4a, 0xb5, 0x73, 0x61, 0x58, 0xc6, 0x30, 0x8e, 0x04, 0x38, 0x2a, 0x78, 0xaf},
		[32]byte{0x86, 0x10, 0x65, 0x27, 0x39, 0xac, 0x0c, 0x6b, 0xb6, 0xb5, 0x35, 0x36, 0x49, 0xbb, 0x82, 0x2b, 0x26, 0x54, 0x3f, 0x0e, 0xbe, 0x88, 0xf3, 0x2a, 0x48, 0x9a, 0x56, 0x84, 0x3c, 0xd0, 0x4f, 0x03},
		[20]byte{0xed, 0x9d, 0x02, 0xe3, 0x82, 0xb3, 0x48, 0x18, 0xe8, 0x8b, 0x88, 0xa3, 0x09, 0xc7, 0xfe, 0x71, 0xe6, 0x5f, 0x41, 0x9d},
		2378237)
	if result {
		return false, errors.New("proof was not invalid as expected")
	}

	result = snark.VerifyUnshielding(proof,
		[32]byte{0x39, 0x2c, 0xeb, 0xa3, 0x2e, 0xf0, 0x24, 0x56, 0xd5, 0x19, 0xf0, 0x66, 0xe6, 0xb6, 0xf8, 0xa2, 0x72, 0xb6, 0x88, 0x4a, 0xb5, 0x73, 0x61, 0x58, 0xc6, 0x30, 0x8e, 0x04, 0x38, 0x2a, 0x78, 0xaf},
		[32]byte{0x88, 0x10, 0x65, 0x27, 0x39, 0xac, 0x0c, 0x6b, 0xb6, 0xb5, 0x35, 0x36, 0x49, 0xbb, 0x82, 0x2b, 0x26, 0x54, 0x3f, 0x0e, 0xbe, 0x88, 0xf3, 0x2a, 0x48, 0x9a, 0x56, 0x84, 0x3c, 0xd0, 0x4f, 0x03},
		[20]byte{0xed, 0x9d, 0x02, 0xe3, 0x82, 0xb3, 0x48, 0x18, 0xe8, 0x8b, 0x88, 0xa3, 0x09, 0xc7, 0xfe, 0x71, 0xe6, 0x5f, 0x41, 0x9d},
		2378237)
	if result {
		return false, errors.New("proof was not invalid as expected")
	}

	result = snark.VerifyUnshielding(proof,
		[32]byte{0x3a, 0x2c, 0xeb, 0xa3, 0x2e, 0xf0, 0x24, 0x56, 0xd5, 0x19, 0xf0, 0x66, 0xe6, 0xb6, 0xf8, 0xa2, 0x72, 0xb6, 0x88, 0x4a, 0xb5, 0x73, 0x61, 0x58, 0xc6, 0x30, 0x8e, 0x04, 0x38, 0x2a, 0x78, 0xaf},
		[32]byte{0x86, 0x10, 0x65, 0x27, 0x39, 0xac, 0x0c, 0x6b, 0xb6, 0xb5, 0x35, 0x36, 0x49, 0xbb, 0x82, 0x2b, 0x26, 0x54, 0x3f, 0x0e, 0xbe, 0x88, 0xf3, 0x2a, 0x48, 0x9a, 0x56, 0x84, 0x3c, 0xd0, 0x4f, 0x03},
		[20]byte{0xec, 0x9d, 0x02, 0xe3, 0x82, 0xb3, 0x48, 0x18, 0xe8, 0x8b, 0x88, 0xa3, 0x09, 0xc7, 0xfe, 0x71, 0xe6, 0x5f, 0x41, 0x9d},
		2378237)
	if result {
		return false, errors.New("proof was not invalid as expected")
	}

	return true, nil
}

// Test copied from from snark_test.go
func (api *PublicZSLAPI) DebugShieldedTransfer() (bool, error) {
	snark.Init()

	proof := snark.ProveTransfer(
		[32]byte{0xde, 0xde, 0xff, 0xdd, 0xde, 0xde, 0xff, 0xdd, 0xde, 0xde, 0xff, 0xdd, 0xde, 0xde, 0xff, 0xdd, 0xde, 0xde, 0xff, 0xdd, 0xde, 0xde, 0xff, 0xdd, 0xde, 0xde, 0xff, 0xdd, 0xde, 0xde, 0xff, 0xdd},
		[32]byte{0xf0, 0xf0, 0xf0, 0xf0, 0x0f, 0x0f, 0x0f, 0xff, 0xff, 0xff, 0xff, 0xf0, 0x00, 0x00, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x00, 0xf0, 0x00, 0x0f, 0x0f, 0x00, 0xf0, 0x0f, 0x0f, 0x0f, 0x0f, 0x00, 0xff},
		2378237,
		0,
		[29][32]byte{
			{0x80, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x01, 0x00},
			{0x80, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x01, 0x00},
			{0x80, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x01, 0x00},
			{0x80, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x01, 0x00},
			{0x80, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x01, 0x00},
			{0x80, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x01, 0x00},
			{0x80, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x01, 0x00},
			{0x80, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x01, 0x00},
			{0x80, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x01, 0x00},
			{0x80, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x01, 0x00},
			{0x80, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x01, 0x00},
			{0x80, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x01, 0x00},
			{0x80, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x01, 0x00},
			{0x80, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x01, 0x00},
			{0x80, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x01, 0x00},
			{0x80, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x01, 0x00},
			{0x80, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x01, 0x00},
			{0x80, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x01, 0x00},
			{0x80, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x01, 0x00},
			{0x80, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x01, 0x00},
			{0x80, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x01, 0x00},
			{0x80, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x01, 0x00},
			{0x80, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x01, 0x00},
			{0x80, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x01, 0x00},
			{0x80, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x01, 0x00},
			{0x80, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x01, 0x00},
			{0x80, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x01, 0x00},
			{0x80, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x01, 0x00},
			{0x80, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x01, 0x00}},
		[32]byte{0xde, 0xde, 0xff, 0xdd, 0xde, 0xde, 0xff, 0xdd, 0xde, 0xde, 0xff, 0xdd, 0xde, 0xde, 0xff, 0xdd, 0xde, 0xde, 0xff, 0xdd, 0xde, 0xde, 0xff, 0xdd, 0xde, 0xde, 0xff, 0xdd, 0xde, 0xde, 0xff, 0xdd},
		[32]byte{0xf0, 0xf0, 0xf0, 0xf0, 0x0f, 0x0f, 0x0f, 0xff, 0xff, 0xff, 0xff, 0xf0, 0x00, 0x00, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x00, 0xf0, 0x00, 0x0f, 0x0f, 0x00, 0xf0, 0x0f, 0x0f, 0x0f, 0x0f, 0x00, 0xff},
		2378237,
		0,
		[29][32]byte{
			{0x80, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x01, 0x00},
			{0x80, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x01, 0x00},
			{0x80, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x01, 0x00},
			{0x80, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x01, 0x00},
			{0x80, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x01, 0x00},
			{0x80, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x01, 0x00},
			{0x80, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x01, 0x00},
			{0x80, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x01, 0x00},
			{0x80, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x01, 0x00},
			{0x80, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x01, 0x00},
			{0x80, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x01, 0x00},
			{0x80, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x01, 0x00},
			{0x80, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x01, 0x00},
			{0x80, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x01, 0x00},
			{0x80, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x01, 0x00},
			{0x80, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x01, 0x00},
			{0x80, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x01, 0x00},
			{0x80, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x01, 0x00},
			{0x80, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x01, 0x00},
			{0x80, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x01, 0x00},
			{0x80, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x01, 0x00},
			{0x80, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x01, 0x00},
			{0x80, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x01, 0x00},
			{0x80, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x01, 0x00},
			{0x80, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x01, 0x00},
			{0x80, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x01, 0x00},
			{0x80, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x01, 0x00},
			{0x80, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x01, 0x00},
			{0x80, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x01, 0x00}},
		[32]byte{0xfb, 0xac, 0xfb, 0xac, 0xfb, 0xac, 0xfb, 0xac, 0xfb, 0xac, 0xfb, 0xac, 0xfb, 0xac, 0xfb, 0xac, 0xfb, 0xac, 0xfb, 0xac, 0xfb, 0xac, 0xfb, 0xac, 0xfb, 0xac, 0xfb, 0xac, 0xfb, 0xac, 0xfb, 0xac},
		[32]byte{0xac, 0xfb, 0xac, 0xfb, 0xac, 0xfb, 0xac, 0xfb, 0xac, 0xfb, 0xac, 0xfb, 0xac, 0xfb, 0xac, 0xfb, 0xac, 0xfb, 0xac, 0xfb, 0xac, 0xfb, 0xac, 0xfb, 0xac, 0xfb, 0xac, 0xfb, 0xac, 0xfb, 0xac, 0xfb},
		2378237,
		[32]byte{0xfb, 0xac, 0xfb, 0xac, 0xfb, 0xac, 0xfb, 0xac, 0xfb, 0xac, 0xfb, 0xac, 0xfb, 0xac, 0xfb, 0xac, 0xfb, 0xac, 0xfb, 0xac, 0xfb, 0xac, 0xfb, 0xac, 0xfb, 0xac, 0xfb, 0xac, 0xfb, 0xac, 0xfb, 0xac},
		[32]byte{0xac, 0xfb, 0xac, 0xfb, 0xac, 0xfb, 0xac, 0xfb, 0xac, 0xfb, 0xac, 0xfb, 0xac, 0xfb, 0xac, 0xfb, 0xac, 0xfb, 0xac, 0xfb, 0xac, 0xfb, 0xac, 0xfb, 0xac, 0xfb, 0xac, 0xfb, 0xac, 0xfb, 0xac, 0xfb},
		2378237)

	result := snark.VerifyTransfer(proof,
		[32]byte{0x86, 0x10, 0x65, 0x27, 0x39, 0xac, 0x0c, 0x6b, 0xb6, 0xb5, 0x35, 0x36, 0x49, 0xbb, 0x82, 0x2b, 0x26, 0x54, 0x3f, 0x0e, 0xbe, 0x88, 0xf3, 0x2a, 0x48, 0x9a, 0x56, 0x84, 0x3c, 0xd0, 0x4f, 0x03},
		[32]byte{0x45, 0xcc, 0xb2, 0x10, 0x61, 0x33, 0x18, 0xd0, 0xd1, 0x27, 0xe9, 0x94, 0x7c, 0x2c, 0xe6, 0xb1, 0xb2, 0x46, 0xc5, 0xc2, 0xdd, 0x53, 0x48, 0x9c, 0x1f, 0x39, 0x39, 0x78, 0x43, 0x41, 0x0c, 0x1a},
		[32]byte{0x45, 0xcc, 0xb2, 0x10, 0x61, 0x33, 0x18, 0xd0, 0xd1, 0x27, 0xe9, 0x94, 0x7c, 0x2c, 0xe6, 0xb1, 0xb2, 0x46, 0xc5, 0xc2, 0xdd, 0x53, 0x48, 0x9c, 0x1f, 0x39, 0x39, 0x78, 0x43, 0x41, 0x0c, 0x1a},
		[32]byte{0x35, 0xf7, 0xff, 0x84, 0x5e, 0x47, 0x86, 0xd6, 0x44, 0xc9, 0xc9, 0x05, 0xfe, 0x68, 0xfd, 0x0f, 0x60, 0x2f, 0xea, 0x0b, 0xeb, 0x2c, 0x34, 0x1b, 0xc5, 0xd2, 0xde, 0xfc, 0x17, 0xc3, 0x2e, 0x86},
		[32]byte{0x35, 0xf7, 0xff, 0x84, 0x5e, 0x47, 0x86, 0xd6, 0x44, 0xc9, 0xc9, 0x05, 0xfe, 0x68, 0xfd, 0x0f, 0x60, 0x2f, 0xea, 0x0b, 0xeb, 0x2c, 0x34, 0x1b, 0xc5, 0xd2, 0xde, 0xfc, 0x17, 0xc3, 0x2e, 0x86},
		[32]byte{0xd6, 0x21, 0x8a, 0x07, 0x71, 0x4d, 0xd9, 0xfa, 0xc9, 0x2b, 0xde, 0xef, 0xd3, 0xf4, 0xc0, 0xd7, 0x69, 0xf4, 0x0f, 0x4b, 0x04, 0x3a, 0xd7, 0xe6, 0x7e, 0x73, 0x75, 0xed, 0xc4, 0x98, 0xe4, 0x5c},
		[32]byte{0xd6, 0x21, 0x8a, 0x07, 0x71, 0x4d, 0xd9, 0xfa, 0xc9, 0x2b, 0xde, 0xef, 0xd3, 0xf4, 0xc0, 0xd7, 0x69, 0xf4, 0x0f, 0x4b, 0x04, 0x3a, 0xd7, 0xe6, 0x7e, 0x73, 0x75, 0xed, 0xc4, 0x98, 0xe4, 0x5c})
	if !result {
		return false, errors.New("proof was not valid as expected")
	}

	result = snark.VerifyTransfer(proof,
		[32]byte{0x85, 0x10, 0x65, 0x27, 0x39, 0xac, 0x0c, 0x6b, 0xb6, 0xb5, 0x35, 0x36, 0x49, 0xbb, 0x82, 0x2b, 0x26, 0x54, 0x3f, 0x0e, 0xbe, 0x88, 0xf3, 0x2a, 0x48, 0x9a, 0x56, 0x84, 0x3c, 0xd0, 0x4f, 0x03},
		[32]byte{0x45, 0xcc, 0xb2, 0x10, 0x61, 0x33, 0x18, 0xd0, 0xd1, 0x27, 0xe9, 0x94, 0x7c, 0x2c, 0xe6, 0xb1, 0xb2, 0x46, 0xc5, 0xc2, 0xdd, 0x53, 0x48, 0x9c, 0x1f, 0x39, 0x39, 0x78, 0x43, 0x41, 0x0c, 0x1a},
		[32]byte{0x45, 0xcc, 0xb2, 0x10, 0x61, 0x33, 0x18, 0xd0, 0xd1, 0x27, 0xe9, 0x94, 0x7c, 0x2c, 0xe6, 0xb1, 0xb2, 0x46, 0xc5, 0xc2, 0xdd, 0x53, 0x48, 0x9c, 0x1f, 0x39, 0x39, 0x78, 0x43, 0x41, 0x0c, 0x1a},
		[32]byte{0x35, 0xf7, 0xff, 0x84, 0x5e, 0x47, 0x86, 0xd6, 0x44, 0xc9, 0xc9, 0x05, 0xfe, 0x68, 0xfd, 0x0f, 0x60, 0x2f, 0xea, 0x0b, 0xeb, 0x2c, 0x34, 0x1b, 0xc5, 0xd2, 0xde, 0xfc, 0x17, 0xc3, 0x2e, 0x86},
		[32]byte{0x35, 0xf7, 0xff, 0x84, 0x5e, 0x47, 0x86, 0xd6, 0x44, 0xc9, 0xc9, 0x05, 0xfe, 0x68, 0xfd, 0x0f, 0x60, 0x2f, 0xea, 0x0b, 0xeb, 0x2c, 0x34, 0x1b, 0xc5, 0xd2, 0xde, 0xfc, 0x17, 0xc3, 0x2e, 0x86},
		[32]byte{0xd6, 0x21, 0x8a, 0x07, 0x71, 0x4d, 0xd9, 0xfa, 0xc9, 0x2b, 0xde, 0xef, 0xd3, 0xf4, 0xc0, 0xd7, 0x69, 0xf4, 0x0f, 0x4b, 0x04, 0x3a, 0xd7, 0xe6, 0x7e, 0x73, 0x75, 0xed, 0xc4, 0x98, 0xe4, 0x5c},
		[32]byte{0xd6, 0x21, 0x8a, 0x07, 0x71, 0x4d, 0xd9, 0xfa, 0xc9, 0x2b, 0xde, 0xef, 0xd3, 0xf4, 0xc0, 0xd7, 0x69, 0xf4, 0x0f, 0x4b, 0x04, 0x3a, 0xd7, 0xe6, 0x7e, 0x73, 0x75, 0xed, 0xc4, 0x98, 0xe4, 0x5c})
	if result {
		return false, errors.New("proof was not invalid as expected")
	}

	return true, nil
}
